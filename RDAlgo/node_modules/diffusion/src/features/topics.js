var _interface = require('util/interface').interface;

var Topics = _interface('Topics', [
   /**
    * Subscribe the session to a topic selector in order to receive updates and
    * subscription events.
    * <P>
    * Subscription causes the server to establish a subscription for this
    * session to any topic that matches the specified selector, including topics
    * that are added after the initial call to {@link Session#subscribe}.
    * <P>
    * If the provided selector string does not begin with one of the prefixes
    * defined by {@link TopicSelectors}, it will be treated as a direct topic
    * path.
    * <P>
    * An optional callback function may be provided, which will be automatically
    * bound to the returned {@link Subscription}'s <code>update</code> event.
    * <P>
    * A {@link Subscription} will emit all topic events that match the provided
    * selector. Documentation of these events is available on the {@link Subscription}
    * page.
    * <P>
    * When calling {@link Session#subscribe}, a {@link Subscription} object is
    * returned to bind event listeners to. This object may be closed via
    * {@link Subscription#close}, which will remove all event listeners and emit
    * no further events. Closing a {@link Subscription} object is different to
    * unsubscribing via {@link Session#unsubscribe} as it is a purely client-side
    * operation that only affects the single {@link Subscription} returned from the
    * initial {@link Session#subscribe} call.
    *
    *
    * @example
    * // Subscribe to a single topic with a callback function for updates
    * session.subscribe('foo/bar', function(update) {
    *     console.log('Update : ' + update);
    * });
    *
    * @example
    * // Subscribe to multiple topics and handle subscription events
    * session.subscribe('?foo/.*').on({
    *     open : function(subscription) {
    *         console.log('Opened subscription for: ' + subscription.selector);
    *     },
    *     update : function(update, topic) {
    *         console.log('Update for ' + topic + ' : ' + update);
    *     },
    *     subscribe : function(details, topic) {
    *         console.log('Subscribed to : ' + topic);
    *     },
    *     unsubscribe : function(reason, topic) {
    *         console.log('Unsubscribed from : ' + topic);
    *     }
    * });
    *
    * @example
    * // Assign subscription and bind multiple listeners
    * var subscription = session.subscribe('?foo/.*');
    *
    * subscription.on('update', callback1);
    * subscription.on('update', callback2);
    *
    * @param {String} selector - The topic selector to subscribe to.
    * @param {Function} [callback] - An optional callback for update events
    * @returns {Subscription} A representation of this session's subscription
    * @function Session#subscribe
    */
    'subscribe',

    /**
     * Unsubscribe the client from a given topic selector.
     * <P>
     * No more updates will be received from the server for any topics matched
     * by the selector.
     * <P>
     * Each topic that this session is unsubscribed from will cause any
     * associated {@link Subscription}s to emit an <code>unsubscribe</code>
     * event. Any {@link Subscription} objects produced from {@link Session#subscribe}
     * or {@link Session#stream} will remain open, and will continue to emit
     * updates for topics that the session has not been unsubscribed from.
     *
     * @example
     * session.unsubscribe('foo');
     *
     * @param {String} selector - The topic selector to unsubscribe from.
     * @returns {Result<undefined>} A {@link Result<undefined>} for this operation
     * @function Session#unsubscribe
     */
    'unsubscribe',

    /**
     * Create a {@link Subscription} stream to receive updates from topics that match the provided topic selector.
     * <P>
     * This method operates in a similar way to {@link Session#subscribe}, except it will not cause the server to
     * send any topic updates unless already subscribed. This allows the registration of listeners prior to actually
     * subscribing, or to add/remove listeners independently of subscriptions on the server.
     * <P>
     * If no selector is provided, the {@link Subscription} stream created will receive all topic events that have not
     * been handled by other subscription streams registered to specific selectors. This allows the handling of topic
     * events for topics that this session has been subscribed to by other control sessions.
     * <P>
     * An optional callback function may be provided, which will be automatically  bound to the returned 
     * {@link Subscription}'s <code>update</code> event.
     *
     * @example
     * // Establish a listener, but will not receive updates immediately
     * session.stream('foo', function(update, topic) {
     *     console.log('Received an update for : ' + topic, update);
     * });
     * 
     * // Once subscribed, the listener established above will receive topic updates
     * session.subscribe('foo');
     *
     * @example
     * // Maintain a single listener independently of subscriptions/unsubscriptions
     * session.stream('?foo/.*').on('update', function(update, topic) {
     *     console.log('Received an update for : ' + topic, update);
     * });
     *
     * // The session can subscribe and unsubscribe from specific selectors separately from receiving updates.
     * session.subscribe('foo/bar');
     * session.unsubscribe('foo/baz');
     *
     * @example
     * // Receive topic events for topics that aren't handled by any other listeners
     * session.stream().on({
     *     update : function(value, topic) {
     *         console.log('Update from: ', topic, value);
     *     },
     *     subscribe : function(details, topic) {
     *         console.log('Subscribed to: ', topic);
     *     },
     *     unsubscribe : function(reason, topic) {
     *         console.log('Unsubscribed from: ', topic);
     *     }
     * });
     *
     * @param {String} [selector] - The topic selector to receive updates for
     * @param {Function} [callback] - An optional callback for update events
     * @returns {Subscription} A representation of the subscription stream
     * @function Session#stream
     */
    'stream',

    /**
     * Produce a {@link View} of multiple topics from a topic selector.
     * <P>
     * A view is a subscription, but instead of an update being issued for
     * each topic in a selector set, the view presents all participating
     * topics in a single structure when any of them are updated.
     * <P>
     * If the topic selector matches a topic which is subsequently added or
     * removed, the update is also fired.
     * <P>
     * Update events will still be emitted by the {@link View}.
     *
     * @example
     * // For an existing topic tree containing foo/bar and foo/baz,
     * // create a view to show updates to foo and below.
     * var view = session.view('?foo//');
     *
     * // Log the current value of the topic 'foo'.
     * console.log(view.foo);
     *
     * // Log the current value of the topic 'foo/bar'.
     * console.log(view.foo.bar);
     *
     * // Log the current value of the topic 'foo/baz'.
     * console.log(view.foo.baz);
     *
     * // Convert the value of foo/bar to a String and log it.
     * view.on('update', function(data) {
     *   console.log(String(data.foo.bar));
     * });
     *
     * @param {String} selector - The topic selector to subscribe topics for the view.
     * @param {Function} [callback] - An optional callback that is invoked when the view is updated.
     * @returns {View} A {@link View View} instance bound to the provided selector
     * @function Session#view
     */
    'view',

    /**
     * Fetch the current state of one or more topics.
     * <P>
     * Fetching a topic will provide its current value without subscribing this client to that topic. The returned
     * {@link FetchStream} will emit <code>value</code> events for each topic that is matched for which a fetch request
     * can be satisfied. Once complete, the {@link FetchStream} will be closed.
     *
     * @param {String|TopicSelector} selector - The topic selector to fetch
     * @returns {FetchStream} A {@link FetchStream} that will emit the fetched values.
     * @function Session#fetch
     *
     * @example
     * // Fetch a topic's value
     * session.fetch("foo").on('value', function(value, path) {
     *     console.log("Value for topic '" + path + "' is: " + value);
     * });
     *
     * @example
     * // Fetch multiple topics, handling possible errors
     * session.fetch("?foo/bar.*").on({
     *     value : function(value, path) { ... },
     *     error : function(error) { ... },
     *     close : function() { ... }
     * });
     */
    'fetch'
]);

module.exports = Topics;
