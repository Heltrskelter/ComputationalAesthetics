var Long = require('long');

/**
 * Sequential reading of values from a given Buffer.
 * Loosely inspired by Java's ByteArrayInputStream.
 * @constructor
 * @param {Buffer} buffer - The source Buffer.
 */
function BufferInputStream(buffer) {
    if (buffer === null || buffer === undefined) {
        throw new Error("Undefined buffer for InputStream");
    }
    
    this.buffer = buffer;
    this.count = buffer.length;
    this.mark = 0;
    this.pos = 0;
}

/**
 * Read one byte. 
 * @returns {Number} The byte that was read, or -1 if the stream is exhausted.
 */
BufferInputStream.prototype.read = function() {
    return (this.pos < this.count) ? (this.buffer[this.pos++] & 0xFF) : -1;
};

/**
 * Read a specified amount of bytes.
 * <P>
 * If the length is greater than the remaining number of bytes, this function 
 * will read up to the last available byte in the buffer.
 * @param {Number} [length] - The number of bytes you wish to read.
 * @returns {Buffer} The bytes that have been read
 * @throws Will throw an OutOfBounds error if length is a negative number.
 */
BufferInputStream.prototype.readMany = function(length) {
    length = Math.min(length, this.count - this.pos);
    
    if (length < 0) {
        throw new Error("Length out of bounds");
    }

    var buffer = this.buffer.slice(this.pos, this.pos + length);
    this.pos += length;
    return buffer;
};

/**
 * Read until a specified byte (delimiter) is found.
 * <p/>
 * The buffer position is updated to point to just after the
 * delimiter.
 * <p/>
 * If the delimiter can't be found, then return all bytes until the
 * end of the buffer.
 *
 * @param {byte} delim - The delimiter byte
 * @returns {Buffer} - A buffer containing the bytes up to but not
 * including the delimiter byte.
 */
BufferInputStream.prototype.readUntil = function(delim) {
    var found = this.count;
    
    for (var i = this.pos; i < this.count; i++) {
        if (this.buffer[i] === delim) {
            found = i;
            break;
        }
    }
    
    var buffer = this.buffer.slice(this.pos, found);
    if (found === this.count) {
        this.pos = found;
    } else {
        this.pos = found + 1;
    }

    return buffer;
};

/**
 * Read a signed 8-bit integer.
 * @returns {Number} The number that has been read.
 */
BufferInputStream.prototype.readInt8 = function() {
    return this.buffer.readInt8(this.pos++);
};

/**
 * Read a signed, big-endian 32-bit integer.
 * @returns {Number} The number that has been read.
 */
BufferInputStream.prototype.readInt32 = function() {
    var i = this.buffer.readInt32BE(this.pos);
    this.pos += 4;
    return i;
};

/**
 * Read a signed, big-endian 64-bit long.
 * @returns {Long} The number that has been read.
 */
BufferInputStream.prototype.readInt64 = function() {
    var hi = this.buffer.readInt32BE(this.pos);
    this.pos += 4;
    var lo = this.buffer.readInt32BE(this.pos);
    this.pos += 4;
   
    return Long.fromBits(lo, hi, false);
};

/**
 * Read an unsigned, big-endian 64-bit long.
 * @returns {Long} The number that has been read.
 */
BufferInputStream.prototype.readUInt64 = function() {
    var hi = this.buffer.readInt32BE(this.pos);
    this.pos += 4;
    var lo = this.buffer.readInt32BE(this.pos);
    this.pos += 4;
   
    return Long.fromBits(lo, hi, true);
};

/**
 * Indicates if there are remaining bytes to be found
 * 
 * @return {Boolean}
 */
BufferInputStream.prototype.hasRemaining = function() {
    return this.pos < this.buffer.length;
};

module.exports = BufferInputStream;
