var _implements = require('util/interface')._implements;
var api = require('../../../content/record-content');

var RecordContent = require('content/structured-record-content/record-content');

function insertFields(record, fn, fields) {
    if (fields) {
        for (var field in fields) {
            var value = fields[field];

            if (value instanceof Array) {
                for (var i = 0; i < value.length; ++i) {
                    fn.call(record, field, value[i], i);
                }
            } else {
                fn.call(record, field, value);
            }
        }
    }
}

var RecordRecordBuilder = _implements(api.Builder.Record,
    function StructuredRecordContentRecordBuilderImpl(meta) {
    var fields = {};

    this.add = function(name, value) {
        var mfield = meta.getField(name);

        if (mfield) {
            if (fields[name] === undefined) {
                fields[name] = [];
            }

            if (mfield.occurs.max === -1 || fields[name].length < mfield.occurs.max) {
                fields[name].push(value);
            } else {
                throw new Error("Field '" + name + "' can only occur up to " + mfield.occurs.max + " times");
            }
        } else {
            throw new Error("Invalid field name  '" + name + "'");
        }

        return this;
    };

    this.set = function(name, value, index) {
        var mfield = meta.getField(name);

        if (mfield) {
            if (fields[name] === undefined) {
                fields[name] = [];
            }

            index = index || 0;

            if (fields[name][index] !== undefined) {
                fields[name][index] = value;
            } else {
                throw new Error("Cannot set nonexistent field '" + name + '" (' + index + ')');
            }
        } else {
            throw new Error("Invalid field name '" + name + "'");
        }

        return this;
    };

    this.build = function() {
        var $fields = {};

        meta.getFields().forEach(function(mfield) {
            var field = mfield.name;
            $fields[field] = [];

            if (fields[field] === undefined) {
                fields[field] = [];
            }

            for (var i = fields[field].length; i < mfield.occurs.min; ++i) {
                fields[field].push(mfield.type.value);
            }

            $fields[field] = fields[field];
        });

        return new RecordContent.Record($fields);
    };
});

var RecordBuilder = _implements(api.Builder,
        function StructuredRecordContentBuilderImpl(meta) {
    var records = {};

    this.add = function(name, fields) {
        var mrecord = meta.getRecord(name);

        if (mrecord) {
            if (records[name] === undefined) {
                records[name] = [];
            }

            if (mrecord.occurs.max === -1 || records[name].length < mrecord.occurs.max) {
                var record = new RecordRecordBuilder(mrecord);
                records[name].push(record);

                insertFields(record, record.add, fields);

                return record;
            } else {
               throw new Error("Record '" + name + "' can only occur up to " + mrecord.occurs.max + " times");
            }
        } else {
            throw new Error("Invalid record name '" + name + "'");
        }
    };

    this.set = function(name, fields, index) {
        var mrecord = meta.getRecord(name);

        if (mrecord) {
            if (records[name] === undefined) {
                records[name] = [];
            }

            index = index || 0;

            if (records[name][index] !== undefined) {
                var record = records[name][index];

                insertFields(record, record.set, fields);

                return record;
            } else {
                throw new Error('Cannot set nonexistent record ' + name + '" (' + index + ')');
            }
        } else {
            throw new Error("Invalid record name '" + name + "'");
        }
    };

    this.build = function() {
        var $records = {};

        meta.getRecords().forEach(function(mrecord) {
            var record = mrecord.name;
            $records[record] = [];

            if (records[record] === undefined) {
                records[record] = [];
            }

            for (var i = records[record].length; i < mrecord.occurs.min; ++i) {
                records[record].push(new RecordRecordBuilder(mrecord));
            }

            for (var j = 0; j < records[record].length; ++j) {
                $records[record].push(records[record][j].build());
            }
        });

        return new RecordContent($records);
    };

    this.addAndBuild = function(name, value) {
        this.add(name, value);
        return this.build();
    };

    this.setAndBuild = function(name, fields, index) {
        this.set(name, fields, index);
        return this.build();
    };

});

module.exports = RecordBuilder;
