var HashMap = require('hashmap');
var Long = require('long');

var ConversationId = require('conversation/conversation-id');
var Conversation = require('conversation/conversation');
var fn = require('util/function');

var log = require('util/logger').create('Conversation Set');

var nextCID = (function() {
    var id = new Long(0);
    return function() {
        id = id.add(1);
        return new ConversationId(id);
    };
}());

function create(errorHandler) {
    var conversations = new HashMap();

    function discard(cid, err) {
        var conversation = conversations.get(cid.toString());

        if (conversation) {
            conversations.remove(cid.toString());
            conversation.discard(cid, err);   
        }
    }

    var bulkhead = function(set, handler, cb) {
        return function(cid) {
            try {
                return fn.callWithArguments(cb, arguments);
            } catch (e) {
                errorHandler.handlerException(cid, e, arguments[1], arguments[2]);
                discard(cid, e);
                return false;
            }
        };
    };

    return {
        new : function(handler) {
            var cid = nextCID();
            var set = this;

            var conversation = new Conversation({
                onOpen      : bulkhead(set, handler, handler.onOpen),
                onResponse  : bulkhead(set, handler, handler.onResponse),
                onDiscard   : bulkhead(set, handler, handler.onDiscard)
            });

            conversations.set(cid.toString(), conversation);
            conversation.open(cid);

            return cid;
        },
        respond : function(cid, r1, r2) {
            var conversation = conversations.get(cid.toString());
            
            if (conversation) {
                var response = conversation.respond(cid, r1, r2);

                switch (response) {
                    case 'ALREADY_FINISHED' :
                        errorHandler.unknownConversation(cid, r1, r2);
                        break;
                    case 'HANDLED_AND_ACTIVE' :
                        break;
                    case 'HANDLED_AND_FINISHED' :
                        conversations.remove(cid.toString());
                        break;
                }
            } else {
                errorHandler.unknownConversation(cid, r1, r2);
            }
        },
        discard : discard,
        discardAll : function(err) {
            conversations.forEach(function(conversation, cid) {
                discard(ConversationId.fromString(cid), err);
            });

            conversations.clear();
        },
        size : function() {
            return conversations.count();
        }
    };
}

module.exports = create;
