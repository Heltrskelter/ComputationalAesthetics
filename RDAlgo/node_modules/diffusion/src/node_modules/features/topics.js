var _implements = require('util/interface')._implements;

var Emitter = require('events/emitter');
var Result = require('events/result');
var View = require('features/topics/view');

var Services = require('services/services');
var parseSelector = require('topics/topic-selector-parser');

var SubscriptionProxy = require('features/topics/subscription-proxy');
var FetchStream = require('features/topics/fetch-stream');

var Topics = require('../../features/topics');

var CloseReason = require('v4-stack/close-reason');

var requireNonNull = require('util/require-non-null');
var logger = require('util/logger').create('Session');

module.exports = _implements(Topics, function TopicsImpl(internal) {
    var unsubscribe = internal.getServiceLocator().obtain(Services.UNSUBSCRIBE);
    var subscribe = internal.getServiceLocator().obtain(Services.SUBSCRIBE);
    var fetch = internal.getServiceLocator().obtain(Services.FETCH);

    var streamRegistry = internal.getStreamRegistry();

    this.subscribe = function(topic, callback) {
        logger.debug('Subscribing', topic);

        var selector = parseSelector(topic);
        var proxy = new SubscriptionProxy(streamRegistry, selector, false, callback);
        
        if (internal.checkConnected(proxy.emitter)) {
            subscribe.send(selector);
        }

        return proxy.subscription;
    };

    this.unsubscribe = function(topic) {
        logger.debug('Unsubscribe request for: ', topic);

        var emitter = new Emitter();
        var result = new Result(emitter);
        var selector;

        try {
            selector = parseSelector(topic);
        } catch (err) {
            emitter.error(err);
            return result;
        }

        if (internal.checkConnected(emitter)) {
            var unsubscribeCallback = function(err, result) {
                if (err) {
                    logger.debug('Unsubscribe failed', topic);
                    emitter.error(err);
                } else {
                    logger.debug('Unsubscribe complete', topic);
                    emitter.emit('complete');
                }
            };

            logger.debug('Unubscribing', topic);
            unsubscribe.send(selector, unsubscribeCallback);
        }
        return result;
    };

    this.stream = function(topic, callback) {
        logger.debug('Establishing topic stream', topic);

        var fallback = false;
        var selector = "";

        if (!topic || typeof topic === 'function') {
            callback = topic;
            fallback = true;
        } else {
            selector = parseSelector(topic);
        }

        var proxy = new SubscriptionProxy(streamRegistry, selector, fallback, callback);

        return proxy.subscription;
    };

    this.fetch = function(selector) {
        logger.debug('Fetch request for: ', selector);

        requireNonNull(selector, "Selector");

        selector = parseSelector(selector);

        var emitter = new Emitter();
        var stream = new FetchStream(emitter);

        if (internal.checkConnected(emitter)) {
            var cid = internal.getConversationSet().new({
                onOpen : function(cid) { },
                onResponse : function(cid, path, content) {
                    if (path) {
                        emitter.emit('value', content, path);
                        return false;
                    } else if (content.length === 1 && content[0] === 1) {
                        emitter.close();
                        return true;
                    } else {
                        emitter.error(new Error("Unexpected end of fetch stream"));
                        return true;
                    }
                },
                onDiscard : function(err) {
                    if (err instanceof CloseReason) {
                        emitter.close();
                    } else {
                        emitter.error(err);
                    }
                }
            });

            fetch.send({
                cid : cid,
                selector : selector
            }, function(err) {
                if (err) {
                    emitter.error(err);
                }
            });
        }

        return stream;
    };

    this.view = function(selector, callback) {
        var s = this.subscribe(selector);
        return new View(s, callback);
    };
});
