var topicSelectorParser = require('topics/topic-selector-parser');

var _implements = require('util/interface')._implements;

var CommandError = require('services/command-error');
var Services = require('services/services');

var ConversationId = require('conversation/conversation-id');
var SessionId = require('session/session-id');

var ControlGroup = require('control/control-group');
var registration = require('control/registration');

var Emitter = require('events/emitter');
var Result = require('events/result');

var api = require('../../features/messages');
var arrays = require('util/array');

var logger = require('util/logger').create('Session.Messages');

// Used because of the serialised form of SessionSendRequest requires a CID
var dummyCID = ConversationId.fromString("0");

function createSendOptions(options) {
    options = options || {};
    options.headers = options.headers || [];
    options.priority = options.priority || 0;

    return options;
}

function MessageStream(e, selector) {
    this.selector = selector;
    e.assign(this);
}

// Returns a session ID if parseable, else false.
function parseSessionId(str) {
    try {
        var sid = SessionId.fromString(str);
        return sid;
    }
    catch(err) {
        return false;
    }
}

module.exports = _implements(api, function MessagesImpl(internal) {
    var conversationSet = internal.getConversationSet();
    var serviceLocator = internal.getServiceLocator();
    
    var sender = serviceLocator.obtain(Services.SEND);
    var sessionSender = serviceLocator.obtain(Services.SEND_TO_SESSION); 
    var filterSender = serviceLocator.obtain(Services.SEND_TO_FILTER);

    var streams = [];

    internal.getServiceRegistry().add(Services.SEND, {
        onRequest : function(internal, message, callback) {
            var received = false;

            streams.forEach(function(stream) {
                if (stream.l.selector.selects(message.path)) {
                    stream.e.emit('message', message);
                    received = true;
                }
            });

            if (received) {
                callback.respond();
            } else {
                logger.info("No messaging streams registered for message on path: " + message.path);

                callback.fail(new CommandError(CommandError.ErrorType.COMMUNICATION_FAILURE,
                    "Session " + internal.getSessionId() +
                    " has no registered streams for message sent to: " + message.path));
            }
        } 
    });

    internal.getServiceRegistry().add(Services.SEND_RECEIVER_CLIENT, {
        onRequest : function(internal, message, callback) {
            callback.respond();
            conversationSet.respond(message.cid, message);
        }
    });

    this.addHandler = function(path, handler, keys) {
        // The registration code will return it's own result - we only make our own for error propagation
        var emitter = new Emitter();
        var result = new Result(emitter);

        if (!path) {
            emitter.error(new Error('Message Handler path is null or undefined'));
            return result;
        }

        if (!handler) {
            emitter.error(new Error('Message Handler is null or undefined'));
            return result;
        }

        if (internal.checkConnected(emitter)) {
            logger.debug('Adding message handler', path);

            var params = {
                definition : Services.SEND_RECEIVER_CLIENT,
                group : ControlGroup.DEFAULT,
                path : path,
                keys : keys !== undefined ? keys : {}
            };

            var adapter = {
                active : function(close) {
                    logger.debug('Message handler active', path);

                    handler.onActive(close);
                },
                respond : function(response) {
                    logger.debug('Message handler response', path);

                    var message = {
                        session : response.sender.toString(),
                        content : response.message,
                        options : response.options,
                        path : response.path
                    };
                    // Only set properties if there are some present.
                    var properties = response.sessionProperties;
                    if (properties && Object.keys(properties).length > 0) {
                        message.properties = properties;
                    }

                    handler.onMessage(message);
                    return false;
                },
                close : function() {
                    logger.debug('Message handler closed', path);

                    handler.onClose();
                }
            };

            return registration.registerMessageHandler(internal, params, adapter);
        } else {
            return result;
        }
    };

    this.listen = function(path, cb) {
        var emitter = new Emitter(undefined, undefined, ['message']);
        var selector = topicSelectorParser(path);

        var stream = new MessageStream(emitter, selector);

        var ref = {
            l : stream, 
            e : emitter
        };

        stream.on('close', function() {
            arrays.remove(streams, ref);
        });

        if (cb && cb instanceof Function) {
            stream.on('message', cb);
        }

        streams.push(ref);
        return stream;
    };

    this.send = function(path, message, options, recipient) {
        var emitter = new Emitter();
        var result = new Result(emitter);

        var sendCallback = function(err, result) {
            if (err) {
                logger.debug('Message send failed', path);
                emitter.error(err);
            } else {
                logger.debug('Message send complete', path);

                // Only filter send returns a result
                if (result) {
                    emitter.emit('complete', {
                        path : path,
                        recipient : recipient,
                        sent : result.sent,
                        errors : result.errors
                    });
                } else {
                    emitter.emit('complete', {
                        path : path,
                        recipient : recipient
                    });
                }
            }
        };
                
        // Arguments are somewhat flexible for this method.
        // path and message are fixed in the first two positions.
        // After that, there may be:
        // 1. options and recipient.
        // 2. Just a recipient.
        // The recipient may either be a Session ID (passed as a string),
        // or a SendFilter.
        if (options && (typeof options === 'string' || options instanceof SessionId)) {
            recipient = options;
            options = createSendOptions();
        } else {
            options = createSendOptions(options);
        }

        if (internal.checkConnected(emitter)) {
            if (!path) {
                emitter.error(new Error('Message path is null or undefined'));
                return result;
            }

            if (message === undefined || message === null) {
                emitter.error(new Error('Message content is null or undefined'));
                return result;
            }

            var request;

            if (recipient) {
                var session = typeof recipient === 'string' ? parseSessionId(recipient) : recipient;
                
                if (session) {
                    request = {
                        path : path,
                        content : message,
                        session : session,
                        options : options,
                        cid : dummyCID
                    };

                    logger.debug('Sending message to session', request);
                    sessionSender.send(request, sendCallback);
                } else { // Try recipient as a client filter.
                    request = {
                        path : path,
                        content : message,
                        filter : recipient,
                        options : options,
                        cid : dummyCID
                    };

                    logger.debug('Sending message to filter', request);
                    filterSender.send(request, sendCallback);
                }
            } else {
                request = {
                    path : path,
                    content : message, 
                    options : options
                };

                logger.debug('Sending message to server', request);
                sender.send(request, sendCallback);
            }
        }

        return result;
    };
});

