var _implements = require('util/interface')._implements;
var Services = require('services/services');

var Emitter = require('events/emitter');
var Result = require('events/result');

var SessionID = require('session/session-id');

var parseSelector = require('topics/topic-selector-parser');
var responseHandler = require('control/registration').responseHandler;
var registrationCallback = require('control/registration').registrationCallback;

var api = require('../../features/client-control');

var arrays = require('util/array');

var ClientControlOptions = require('../../features/client-control-options');
var SessionPropertiesEventType = require('services/control/session-properties-event-type');

var requireNotNull = require('util/require-non-null');
var logger = require('util/logger').create('Session.Clients');

module.exports = _implements(api, function ClientControlImpl(internal) {
    var conversationSet = internal.getConversationSet();
    var serviceLocator = internal.getServiceLocator();

    var getProperties = serviceLocator.obtain(Services.GET_SESSION_PROPERTIES);
    var registration = serviceLocator.obtain(Services.SESSION_PROPERTIES_REGISTRATION_2);

    internal.getServiceRegistry().add(Services.SESSION_PROPERTIES_EVENT_2, {
        onRequest : function(internal, message, callback) {
            conversationSet.respond(message.cid, message);
            callback.respond();
        }
    });

    this.subscribe = function(session, path) {
        var emitter = new Emitter();
        var result = new Result(emitter);

        try {
            requireNotNull(session, "SessionID or Session Filter");
            requireNotNull(path, "Topic Selector");
        } catch (e) {
            emitter.error(e);
            return result;
        }

        if (internal.checkConnected(emitter)) {
            var selector;

            try {
                selector = parseSelector(path);
            } catch (e) {
                emitter.error(e);
                return result;
            }

            var sessionID = SessionID.validate(session);

            if (sessionID) {
                serviceLocator.obtain(Services.SUBSCRIBE_CLIENT).send({
                    sessionID : sessionID,
                    selector : selector
                }, function(err, result) {
                    if (err) {
                        emitter.error(err);
                    } else {
                        emitter.emit('complete');
                    }
                });
            } else {
                serviceLocator.obtain(Services.FILTER_SUBSCRIBE).send({
                    filter : session,
                    selector : selector
                }, function(err, result) {
                    if (err) {
                        emitter.error(err);
                    } else if (result.isSuccess()) {
                        emitter.emit('complete', result.selected);
                    } else {
                        emitter.error(result.errors);
                    }
                });
            }
        }

        return result;
    };

    this.unsubscribe = function(session, path) {
        var emitter = new Emitter();
        var result = new Result(emitter);

        try {
            requireNotNull(session, "SessionID or Session Filter");
            requireNotNull(path, "Topic Selector");
        } catch (e) {
            emitter.error(e);
            return result;
        }

        if (internal.checkConnected(emitter)) {
            var selector;

            try {
                selector = parseSelector(path);
            } catch (e) {
                emitter.error(e);
                return result;
            }

            var sessionID = SessionID.validate(session);

            if (sessionID) {
                serviceLocator.obtain(Services.UNSUBSCRIBE_CLIENT).send({
                    sessionID : sessionID,
                    selector : selector
                }, function(err, result) {
                    if (err) {
                        emitter.error(err);
                    } else {
                        emitter.emit('complete');
                    }
                });
            } else {
                serviceLocator.obtain(Services.FILTER_UNSUBSCRIBE).send({
                    filter : session,
                    selector : selector
                }, function(err, result) {
                    if (err) {
                        emitter.error(err);
                    } else if (result.isSuccess()) {
                        emitter.emit('complete', result.selected);
                    } else {
                        emitter.error(result.errors);
                    }
                });
            }
        }

        return result;
    };

    this.getSessionProperties = function(sid, propertyKeys) {
        var emitter = new Emitter();
        var result = new Result(emitter);

        if (typeof sid === 'string') {
            sid = SessionID.fromString(sid);
        }

        if (internal.checkConnected(emitter)) {
            getProperties.send({
                sessionID : sid,
                propertyKeys : propertyKeys
            }, function(err, result) {
                if (err) {
                    emitter.error(err);
                } else {
                    if (result === null) {
                        emitter.error(new Error('Invalid session ID'));
                    } else {
                        emitter.emit('complete', sid, result.properties);
                    }
                }
            });
        }

        return result;
    };

    this.setSessionPropertiesListener = function(requiredProperties, handler) {
        var emitter = new Emitter();
        var result = new Result(emitter);

        if (!handler) {
            emitter.error(new Error('Session Properties listener is null or undefined'));
        }

        if (internal.checkConnected(emitter)) {
            logger.debug('Adding Session Properties Listener');

            var adapter = {
                active : function(close) {
                    logger.debug('Session Properties Listener active');
                    handler.onActive(close);
                },
                respond : function(message) {
                    for (var i = 0; i < message.events.length; ++i) {
                        var event = message.events[i];

                        switch (event.type) {
                            case SessionPropertiesEventType.OPEN:
                                handler.onSessionOpen(event.sessionId, event.oldProperties);
                                break;
                            case SessionPropertiesEventType.UPDATE:
                                handler.onSessionEvent(
                                    event.sessionId,
                                    event.updateType,
                                    event.newProperties,
                                    event.oldProperties);
                                break;
                            case SessionPropertiesEventType.CLOSE:
                                handler.onSessionClose(
                                    event.sessionId,
                                    event.oldProperties,
                                    event.closeReason);
                                break;
                            default :
                                logger.debug('Unknown event type received for session properties listener', event.type);
                        }
                    }
                },
                close : function(err) {
                    logger.debug('Session Properties Listener closed');

                    if (err) {
                        handler.onError(err);
                    } else {
                        handler.onClose();
                    }
                }
            };

            var cid = conversationSet.new(responseHandler(internal, adapter, function(cid, callback) {
                registration.send({ cid : cid }, callback);
            }));

            registration.send(
                    { cid : cid, properties : requiredProperties },
                    registrationCallback(conversationSet, cid, emitter)); 
        }

        return result;
    };
});
