var _implements = require('util/interface')._implements;
var Services = require('services/services');

var Emitter = require('events/emitter');
var Result = require('events/result');

var ControlGroup = require('control/control-group');
var registerTopicHandler = require('control/registration').registerTopicHandler;

var updateResponseHandler = require('features/update-response-handler');

var TopicAddFailReason = require('../../topics/topics').TopicAddFailReason;

var WillResult = require('services/wills/will-registration-result');
var WillParams = require('services/wills/topic-will-parameters');

var RecordContent = require('content/record-content/record-content');
var Update = require('update/update').Update;

var UniversalUpdater = require('features/topic-control/universal-updater');
var ValueCache = require('features/topic-control/value-cache');

var parseSelector = require('topics/topic-selector-parser');
var deriveDetails = require('topics/details/topic-details').deriveDetails;
var util = require('metadata/util');

var api = require('../../features/topic-control');

var logger = require('util/logger').create('Session.Topics');

module.exports = _implements(api.TopicControl, function TopicControlImpl(internal) {
    var conversationSet = internal.getConversationSet();
    var serviceLocator = internal.getServiceLocator();

    var ADD_SERVICE = serviceLocator.obtain(Services.ADD_TOPIC);
    var REMOVE_SERVICE = serviceLocator.obtain(Services.REMOVE_TOPIC);
    var UPDATE_SERVICE = serviceLocator.obtain(Services.UPDATE_TOPIC);
    var TOPIC_REMOVAL = serviceLocator.obtain(Services.TOPIC_REMOVAL);
    var TOPIC_WILL_REGISTRATION = serviceLocator.obtain(Services.TOPIC_SCOPED_WILL_REGISTRATION);
    var TOPIC_WILL_DEREGISTRATION = serviceLocator.obtain(Services.TOPIC_SCOPED_WILL_DEREGISTRATION);
    var UPDATE_SOURCE_REGISTRATION = serviceLocator.obtain(Services.UPDATE_SOURCE_REGISTRATION);

    var valueCache = new ValueCache();
    var universalUpdater = new UniversalUpdater(internal);

    // Updater state service
    internal.getServiceRegistry().add(Services.UPDATE_SOURCE_STATE, {
        onRequest : function(internal, message, callback) {
            callback.respond();

            conversationSet.respond(message.cid, {
                old : message.old,
                current : message.current
            });
        }
    });

    internal.getServiceRegistry().add(Services.MISSING_TOPIC, {
        onRequest : function(internal, request, callback) {
            conversationSet.respond(request.cid, {
                request : request,
                callback : function(val) {
                    callback.respond(val);
                }
            });
        }
    });

    this.add = function() {
        var path;
        var details;
        var content;

        var emitter = new Emitter();
        var result = new Result(emitter);

        switch (arguments.length) {
        case 1: // Topic name only.
            path = arguments[0];
            details = deriveDetails();
            break;
        case 2: // Topic and metadata (possibly derived).
            path = arguments[0];
            details = deriveDetails(arguments[1]);
            content = details.content;
            break;
        case 3: // Topic, metadata and explicit content.
            path = arguments[0];
            details = deriveDetails(arguments[1]);
            content = arguments[2];
            break;
        default:
            emitter.error({ id : 0, reason : 'Incorrect number of parameters supplied to add() function' });
            return result;
        }

        if (internal.checkConnected(emitter)) {
            logger.debug('Adding topic', path);

            ADD_SERVICE.send({
                path : path, details : details, content : content
            }, function(err, result) {
                if (err) {
                    emitter.error(err);
                } else {
                    switch (result.status) {
                    case 0:
                    case 1:
                        logger.debug("Topic add complete", path);

                        valueCache.put(path, content);

                        emitter.emit('complete', {
                            topic : path, 
                            added : true
                        });
                        break;
                    case 2:
                        // Special case - the topic already exists with same details
                        // This emits 'complete' because add topic is idempotent
                        if (result.reason === TopicAddFailReason.EXISTS) {
                            logger.debug("Topic add complete (already exists)", path);

                            valueCache.put(path, content);

                            emitter.emit('complete', {
                                topic : path, 
                                added : false
                            });
                        } else {
                            logger.debug("Topic add failed", path);
                            emitter.error(result.reason);
                        }

                        break;
                    case 3:
                        emitter.error({ id : 0, reason : 'Cache failure' });
                        break;
                    }
                }
            });
        }

        return result;
    };
    
    this.remove = function(path) {
        var emitter = new Emitter();
        var result = new Result(emitter);

        if (internal.checkConnected(emitter)) {
            logger.debug('Removing topic', path);

            try {
                REMOVE_SERVICE.send({
                    selector: parseSelector(path)
                }, function (error, result) {
                    if (error) {
                        logger.debug('Topic removal failed', path);

                        emitter.error(error);
                    } else {
                        logger.debug('Topic removal complete', path);

                        emitter.emit('complete');
                    }
                });
            } catch (err) {
                logger.debug('Error parsing selector', path);
                emitter.error(err);
            }
        }

        return result;
    };

    this.removeSelector = function(expression) {
        var emitter = new Emitter();
        var result = new Result(emitter);

        if (internal.checkConnected(emitter)) {
            logger.debug('Removing topics', expression);

            try {
                TOPIC_REMOVAL.send({
                    selector : parseSelector(expression)
                }, function(err) {
                    if (err) {
                        logger.debug('Topic removal failed', expression);
                        emitter.error(err);
                    } else {
                        logger.debug('Topic removal complete', expression);
                        emitter.emit('complete');
                    }
                });
            } catch (err) {
                logger.debug('Error parsing selector', expression);
                emitter.error(err);
            }
        }

        return result;
    };
    
    this.removeWithSession = function(path) {
        var emitter = new Emitter();
        var result = new Result(emitter);

        if (internal.checkConnected(emitter)) {
            logger.debug('Registering removeWithSession', path);

            var params = new WillParams(path, WillParams.Will.REMOVE_TOPICS);

            TOPIC_WILL_REGISTRATION.send(params, function(err, result) {
                if (err) {
                    logger.debug('removeWithSession registration failed', path);
                    emitter.error(err);
                } else if (result === WillResult.SUCCESS) {
                    logger.debug('removeWithSession registration complete', path);

                    var registered = true;

                    var dEmitter = new Emitter();
                    var dResult = new Result(dEmitter);

                    var deregister = function() {
                        if (registered && internal.checkConnected(dEmitter)) {
                            logger.debug('Deregistering removeWithSession', path);

                            TOPIC_WILL_DEREGISTRATION.send(params, function(err, result) {
                                if (err) {
                                    dEmitter.error(err);
                                } else {
                                    registered = false;
                                    dEmitter.emit('complete', {
                                        topic : path
                                    });
                                }
                            });
                        }

                        return dResult;
                    };

                    emitter.emit('complete', {
                        deregister : deregister
                    });
                } else {
                    logger.debug('removeWithSession registration failed', path);
                    emitter.error(new Error('REGISTRATION_CONFLICT'));
                }
            });
        }

        return result;
    };

    this.update = function(path, content) {
        var emitter = new Emitter();
        var result = new Result(emitter);

        if (internal.checkConnected(emitter)) {
            logger.debug('Updating topic', path);

            var callback = function(error, result) {
                if (error) {
                    logger.debug('Update failed', path);

                    emitter.error(error);
                } else if (result.isError) {
                    logger.debug('Update failed', path);

                    emitter.error(result.reason);
                } else {
                    logger.debug('Update complete', path);

                    emitter.emit('complete', path);
                }
            };

            if (util.isMetadataValue(content)) {
                UPDATE_SERVICE.send({
                    path : path,
                    update : new Update(content)
                }, callback);
            } else {
                universalUpdater.update(path, content, callback);
            }
        }

        return result;
    };

    this.registerUpdateSource = function(path, handler) {
       var emitter = new Emitter();
       var result = new Result(emitter);

       var conversations = internal.getConversationSet();
       var cid = conversations.new(updateResponseHandler(internal, valueCache, path, handler));

       if (internal.checkConnected(emitter)) {
           UPDATE_SOURCE_REGISTRATION.send({
               cid : cid,
               path : path
           }, function(err, state) {
               if (err || state === 'closed') {
                   conversations.discard(cid, err);
                   emitter.error(err);
               } else {
                   conversations.respond(cid, { old : 'init', current : state });
                   emitter.emit('complete');
               }
           });
       }

       return result;
    };

    this.addMissingTopicHandler = function(path, handler) {
        var emitter = new Emitter();
        var result = new Result(emitter);

        if (!handler) {
            emitter.error(new Error('Missing Topic handler is null or undefined'));
            return result;
        }

        if (internal.checkConnected(emitter)) {
            var adapter = {
                active : function(close) {
                    logger.debug('Missing Topic Handler registered for ' + path);
                    handler.onRegister(path, close);
                },
                respond : function(response) {
                    logger.debug('Missing Topic Handler notification for ' +
                        response.request.sessionID +
                        ' using ' +
                        response.request.selector);

                    handler.onMissingTopic({
                        path : response.request.selector.prefix,
                        selector : response.request.selector,
                        sessionID : response.request.sessionID,
                        proceed : function() {
                            response.callback(true);
                        },
                        cancel : function() {
                            response.callback(false);
                        }
                    });
                },
                close : function(err) {
                    logger.debug('Missing Topic Handler closed for ' + path);
                    if (err) {
                        handler.onError(path, err);
                    } else {
                        handler.onClose(path);
                    }
                }
            };

            var params = {
                definition : Services.MISSING_TOPIC,
                group : ControlGroup.DEFAULT,
                path : path
            };

            return registerTopicHandler(internal, params, adapter);
        }

        return result;
    };
});
