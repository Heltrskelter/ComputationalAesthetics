var TypedSubscriptionImpl = require('features/topics/typed-subscription');
var TopicType = require('../../../topics/topics').TopicType;
var Emitter = require('events/emitter');

/**
 * Internal proxy for Subscriptions with an underlying datatype.
 *
 * @param registry - StreamRegistry
 * @param selector - Topic selector
 * @param datatype - The datatype
 * @param callback - Optional callback for subscription
 */
module.exports = function TypedSubscriptionProxy(registry, selector, datatype, fallback, callback) {
    var emitter = new Emitter();
    var stream = emitter.get();
    var self = this;

    var subscription = new TypedSubscriptionImpl(registry, stream, selector);
    var pending = true;

    stream.on('close', function() {
        registry.remove(self);
    });

    this.subscription = subscription;
    this.emitter = emitter;

    this.selects = function(details) {
        if (details) {
            return details.type === TopicType[datatype.name().toUpperCase()];
        }

        return false;
    };

    this.onOpen = function() {
        emitter.emit('open', subscription);
    };

    this.onDelta = function(topic, details, received, delta, oldValue, newValue) {
        emitter.emit('value', topic, details, newValue, oldValue);
    };

    this.onValue = function(topic, details, received, oldValue, newValue) {
        emitter.emit('value', topic, details, newValue, oldValue);
    };

    this.onSubscription = function(topic, details) {
        emitter.emit('subscribe', topic, details);
    };

    this.onUnsubscription = function(topic, details, reason) {
        emitter.emit('unsubscribe', topic, details, reason);
    };

    if (callback) {
        subscription.on('value', callback);

        if (fallback) {
            registry.addFallback(self);
        } else {
            registry.add(selector, self);
        }
    } else {
        // Monkey-patch so that we will only register this stream if it is subsequently used
        subscription.on = function(event, fn) {
            if (pending) {
                if (fallback) {
                    registry.addFallback(self);
                } else {
                    registry.add(selector, self);
                }

                pending = false;
            }

            return stream.on.call(subscription, event, fn);
        };
    }
};