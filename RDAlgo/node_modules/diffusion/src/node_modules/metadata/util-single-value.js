// Hack to avoid circular dependencies when checking types / deriving values
// within RecordContent metadata implementation

var MStateless = require('./stateless');
var MDecimal = require('./decimal');
var MInteger = require('./integer');
var MString = require('./string');
var Type = require('../../topics/topics').TopicType;

function createFromSingleValue(value) {
    switch (typeof value) {
    case 'string' :
        return new MString(value);
    case 'number' :
        var str = '' + value, i = str.indexOf('.');

        if (i > -1) {
            return new MDecimal(value, str.length - (i + 1));
        } else {
            return new MInteger(value);
        }
    }

    throw new Error('Invalid Single Value type', value);
}

function getType(metadata) {
    if (metadata instanceof MDecimal ||
        metadata instanceof MInteger ||
        metadata instanceof MString) {
        return Type.SINGLE_VALUE;
    } else if (metadata instanceof MStateless) {
        return Type.STATELESS;
    }

    throw new Error('Unknown metadata type');
}

function isMetadata(value) {
    return value instanceof MStateless ||
           value instanceof MDecimal ||
           value instanceof MInteger ||
           value instanceof MString;
}

function isMetadataValue(value) {
    return isMetadata(value) ||
        typeof value === "string" ||
        typeof value === "number" ||
        typeof value === "boolean" ||
        value === undefined;
}

function deriveMetadata(value) {
    if (value === undefined) {
        return new MStateless();
    }

    if (isMetadata(value)) {
        return value;
    }

    return createFromSingleValue(value);
}

module.exports = {
    Type : Type,
    getType : getType,
    isMetadata : isMetadata,
    isMetadataValue : isMetadataValue,
    deriveMetadata : deriveMetadata
};