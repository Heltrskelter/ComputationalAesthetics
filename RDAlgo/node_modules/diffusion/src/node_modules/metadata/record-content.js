var _implements = require('util/interface')._implements;
var Metadata = require('../../metadata/metadata');

var RecordContentParser = require('content/structured-record-content/parser');
var RecordContentBuilder = require('content/structured-record-content/builder');

var MDecimal = require('./decimal');
var MInteger = require('./integer');
var MString = require('./string');

var util = require('./util-single-value');

var count = 0;

function occurs(m, n) {
    var min = 1, max = 1;

    if (m !== undefined) {
        if (typeof(m) === 'string') {
            var i = m.indexOf('.');

            if (i !== -1) {
                var j = m.lastIndexOf('.');

                min = m.substring(0, i);
                max = m.substring(j + 1);

                if (max === '*') {
                    max = -1;
                }
            } else {
                min = m;
                max = m;
            }
        } else if (typeof(m) === 'number') {
            min = m;

            if (n !== undefined && typeof (n) === 'number') {
                max = n;
            } else {
                max = m;
            }
        } else if (m.min !== undefined) {
            min = m.min;
            max = m.max;
        }

        if (max === undefined) {
            max = min;
        }

        min = parseInt(min, 10);
        max = parseInt(max, 10);
    }

    return {
        min : min,
        max : max,
        toString : function() {
            var min = this.min;
            var max = this.max > -1 ? this.max : '*';

            return min === max ? '' + min : min + '..' + max;
        }
    };
}

var MFieldImpl = _implements(Metadata.RecordContent.Field, function MField(name, type, occurs) {
    this.name = name;
    this.occurs = occurs;

    if (type) {
        var t  = util.deriveMetadata(type);

        if (util.getType(t) !== util.Type.SINGLE_VALUE) {
            throw new Error('Record fields can only have single values (string, integer or decimal)');
        }

        this.type = t;
    } else {
        this.type = new MString();
    }

    this.getDetails = function() {
        var details = this.type.getDetails();

        details.name = name;
        details.multiplicity = occurs.toString();

        return details;
    };
});

var MRecordImpl = _implements(Metadata.RecordContent.Record, function MRecord(name, m) {
    var fields = {};
    var order = [];

    this.name = name;
    this.occurs = m;

    this.getField = function(name) {
        switch (typeof name) {
        case 'string' :
            return fields[name];
        case 'number' :
            return fields[order[name]];
        }

        return undefined;
    };

    this.getFields = function() {
        return order.map(function(name) {
            return fields[name];
        });
    };

    this.addField = function(name, type, m) {
        if (fields[name]) {
            throw new Error('Field metadata already exists for: ' + name);
        }

        var previous = fields[order[order.length - 1]];
        if (previous && previous.occurs.min !== previous.occurs.max) {
            throw new Error('Fields cannot be added after a repeating field');
        }

        var field = new MFieldImpl(name, type, occurs(m));

        fields[name] = field;
        order.push(name);

        return field;
    };

    this.getDetails = function() {
        return {
            name : name,
            multiplicity : m.toString()
        };
    };
});

var MRecordContentImpl = _implements(Metadata.RecordContent, function MRecordContent(name) {
    var parser = new RecordContentParser(this);
    var self = this;

    var records = {};
    var order = [];

    name = name || 'MRecordData' + (count++);

    this.addRecord = function(name, m, fields) {
        if (records[name]) {
            throw new Error('Record metadata already exists for: ' + name);
        }

        var previous = records[order[order.length - 1]];
        if (previous && previous.occurs.min !== previous.occurs.max) {
            throw new Error('Records cannot be added after a repeating record');
        }

        var record = new MRecordImpl(name, occurs(m));
        records[name] = record;
        order.push(name);

        if (fields !== undefined) {
            for (var field in fields) {
                record.addField(field, fields[field]);
            }
        }

        return record;
    };

    this.getRecord = function(name) {
        switch (typeof name) {
        case 'string' :
            return records[name];
        case 'number' :
            return records[order[name]];
        }

        return undefined;
    };

    this.getRecords = function() {
        return order.map(function(name) {
            return records[name];
        });
    };

    this.occurs = occurs;
    this.name = name;

    this.string = function(val) {
        return new MString(val);
    };

    this.integer = function(val) {
        return new MInteger(val);
    };

    this.decimal = function(val, scale) {
        return new MDecimal(val, scale);
    };

    this.getDetails = function() {
        return { name : name };
    };

    this.builder = function() {
        return new RecordContentBuilder(self);
    };

    this.parse = function(buffer) {
        return parser.parse(buffer);
    };
});

module.exports = MRecordContentImpl;
