var inherits = require('inherits');
var BufferOutputStream = require('io/buffer-output-stream');
var BufferInputStream = require('io/buffer-input-stream');

var systemHeaders = {
    0 : [],
    1 : [],
    2 : [],
    20 : ['topic'],
    21 : ['topic'],
    22 : ['topic_set'],
    23 : ['topic_set'],
    24 : ['timestamp', 'queue_size'],
    25 : ['timestamp'],
    26 : ['username', 'password'],
    27 : ['username', 'password'],
    28 : [],
    29 : [],
    30 : ['topic', 'ack_id'],
    31 : ['topic', 'ack_id'],
    32 : ['ack_id'],
    33 : ['topic'],
    34 : ['topic'],
    35 : ['topic', 'topic_status'],
    36 : ['topic', 'command'],
    40 : ['topic', 'command_topic_category', 'command_topic_type'],
    41 : ['topic', 'notification_type'],
};

var types = {
    SERVICE_REQUEST : 0,
    SERVICE_RESPONSE : 1,
    SERVICE_ERROR : 2,
    TOPIC_LOAD : 20,
    DELTA : 21,
    SUBSCRIBE : 22,
    UNSUBSCRIBE : 23,
    PING_SERVER : 24,
    PING_CLIENT : 25,
    CREDENTIALS : 26,
    CREDENTIALS_REJECTED : 27,
    ABORT_NOTIFICATION : 28,
    CLOSE_REQUEST : 29,
    TOPIC_LOAD_ACK_REQUIRED : 30,
    DELTA_ACK_REQUIRED : 31,
    ACK : 32,
    FETCH : 33,
    FETCH_REPLY : 34,
    TOPIC_STATUS_NOTIFICATION : 35,
    COMMAND_MESSAGE : 36,
    COMMAND_TOPIC_LOAD : 40,
    COMMAND_TOPIC_NOTIFICATION : 41,
};

var encoding = {
    NONE : 0,
    ENCRYPTION_REQUESTED : 1,
    COMPRESSION_REQUESTED : 2,
    BASE64_REQUESTED : 3,
    ENCRYPTED : 17,
    COMPRESSED : 18,
    BASE64 : 19
};

var parse = function(buffer) {
    var bis = new BufferInputStream(buffer);

    var type = bis.read();

    if (systemHeaders[type] === undefined) {
        throw new Error('Invalid message type: ' + type);
    }

    // Parse new service message type
    if (type === types.SERVICE_REQUEST || type === types.SERVICE_RESPONSE || type === types.SERVICE_ERROR) {
        return parseServiceMessage(type, bis);
    }

    var headers = bis.readUntil(0x01).toString().split('\u0002');
    
    var body = bis.readMany(bis.count); 
    
    var fields = {};

    if (systemHeaders[type]) {
        systemHeaders[type].forEach(function(key) {
            fields[key] = headers.shift();
        });
    }
    return new Message(type, encoding.NONE, fields, body, headers);
};

function parseServiceMessage(type, bis) {
    var headers = [];
    
    var body = bis.readMany(bis.count); 
    
    var fields = {};

    return new Message(type, encoding.NONE, fields, body, headers);
}

/**
 * Create a writeable Message.
 *
 * The returned value inherits functionality from BufferOutputStream.
 *
 * @param {Number|Object} - Provide a number to specify a message type; use an object to provide fields
 * @returns {Message} The created message
 */
var create = function(type) {
    var fields;

    if (type === undefined || (typeof type === "number" && systemHeaders[type] === undefined)) {
        throw "Invalid message type: " + type;
    } else if (type instanceof Object) {
        fields = type;
    } else {
        fields = { type : type };
    }

    fields.encoding = fields.encoding || 0;
    fields.headers = fields.headers || [];
    fields.buffer = fields.buffer || new Buffer(0);

    return new WriteableMessage(fields);
};

var getHeaderString = function(message) {
    var sh = [];
    var headers = '';

    systemHeaders[message.type].forEach(function(h) {
        sh.push(message[h]);
    });

    message.headers.forEach(function(h) {
        sh.push(h);
    });

    // CLOSE_REQUEST has no header or body
    if (systemHeaders[message.type].length === 0) {
        return headers;
    }

    if (sh.length > 0) {
        headers =  sh.join('\u0002');
        headers += '\u0001';
    }

    return headers;
};

function writeToBuffer(message, bos) {
    bos.write(message.type);
    bos.writeString(getHeaderString(message));
    bos.writeMany(message.getBuffer());
}

function WriteableMessage(fields) {
    Message.call(this, fields.type, fields.encoding, fields, fields.buffer, fields.headers);
    BufferOutputStream.call(this, fields.buffer);
}

inherits(WriteableMessage, BufferOutputStream);

function Message(type, encoding, fields, data, headers) {
    this.type = type;
    this.encoding = encoding;

    for (var f in fields) {
        this[f] = fields[f];
    }

    this.data = data;
    this.headers = headers;
}

Message.prototype.isTopicMessage = function() {
    return this.topic !== undefined;
};

Message.prototype.isServiceMessage = function() {
     return this.type === types.SERVICE_REQUEST ||
            this.type === types.SERVICE_RESPONSE ||
            this.type === types.SERVICE_ERROR;
};

Message.prototype.getInputStream = function() {
    return new BufferInputStream(this.data);
};

module.exports = {
    types : types,
    parse : parse,
    create : create,
    encoding : encoding,
    getHeaderString : getHeaderString,
    writeToBuffer : writeToBuffer
};
