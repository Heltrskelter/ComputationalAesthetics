import * as diffusion from './diffusion.d';

// The purpose of this test is to keep the TypeScript definition in sync with the API
// It uses every Diffusion API call and should compile

const TOPIC_PATH = 'f/o/o/b/a/r';
diffusion.log('silent');
diffusion.log('error');
diffusion.log('warn');
diffusion.log('info');
diffusion.log('debug');

// Test transports
diffusion.connect({
  transports: "WS"
});
diffusion.connect({
  transports: ["WS", "XHR"]
});


diffusion.connect({
  host: 'localhost',
  port: 8080,
  principal: 'admin',
  credentials: 'password'
}).then(function(session) {

  // Session methods
  session.close();
  session.isConnected();
  session.isClosed();

  // Datatypes
  var jsonType = diffusion.datatypes.json();
  var binaryType = diffusion.datatypes.binary();
  var value = jsonType.from({ "hello" : "world" });
  var value = jsonType.fromJsonString("{\"hello\": \"world\"}");
  var value = diffusion.datatypes.JSONDataType.from({"test": "test"});
  var value = diffusion.datatypes.JSONDataType
    .fromJsonString("{\"hello\": \"world\"}");

  // Topictype
  var jsonTopicType = diffusion.topics.TopicType.JSON;
  var binaryTopicType = diffusion.topics.TopicType.BINARY;
  var recordTopicType = diffusion.topics.TopicType.RECORD;
  var singleValueTopicType = diffusion.topics.TopicType.SINGLE_VALUE;

  // Metadata
  var metadata = new diffusion.metadata.RecordContent();
  var builder = metadata.builder();
  var val = builder.build();
  metadata.addRecord('foo', metadata.occurs(0, 5));
  metadata.addRecord('foo', metadata.occurs(1), {
      field1 : metadata.integer(),
      field2 : metadata.string()
  });
  var metadataString = new diffusion.metadata.String();
  var metadataInteger = new diffusion.metadata.Integer();
  var metadataDecimal = new diffusion.metadata.Decimal();

  // Topics
  var subscription = session.subscribe(TOPIC_PATH, () => {});
  var result1 = session.unsubscribe(TOPIC_PATH);
  var subscription = session.stream(TOPIC_PATH, () => {});
  var view = session.view(TOPIC_PATH, () => {});
  var fetchStream = session.fetch(TOPIC_PATH);

  // Subscription
  var selectorTest: string = subscription.selector;
  var typedSubscription = subscription.asType(jsonType);
  var typedSubscription = subscription.asType(binaryType);
  var view = subscription.view;
  var subscription = subscription.transform(String);
  subscription.close();

  // Topic Control
  session.topics.add('foo/bing', metadata, val);
  session.topics.add(TOPIC_PATH, { "test": 123 });
  session.topics.add(TOPIC_PATH, jsonType.from({ "hello" : "world" }));
  session.topics.remove(TOPIC_PATH);
  session.topics.removeWithSession(TOPIC_PATH);
  session.topics.update(TOPIC_PATH, 'x').then((path) => {
      console.log("Updated path: " + path);
      return path + "!";
  }).then((path) => {
    console.log("Path: " + path);
  });
  session.topics.registerUpdateSource(TOPIC_PATH, {
    onRegister: (topicPath, unregister)  => {},
    onActive: (topicPath, updater)  => {
      updater.update(TOPIC_PATH, 'x');
    },
    onStandBy: (topicPath)  => {},
    onClose: (topicPath)  => {},
  });

  // Client Control
  session.clients.subscribe('XXX-YYY', TOPIC_PATH);
  session.clients.unsubscribe('XXX-YYY', TOPIC_PATH);
  session.clients.getSessionProperties('XXX-YYY', ['$x', '$y', '$z'])
    .then((properties) => {}, () => {})
    .then((properties) => {});
  session.clients.setSessionPropertiesListener(['$q', '$w', '$e'], {
    onActive: (deregister) => {},
    onClose: () => {},
    onSessionOpen: (session, properties) => {},
    onSessionEvent: (session, sessionEventType, properties, previous) => {
      var eventType: number = sessionEventType;
    },
    onSessionClose: (session, properties, reason) => {}
  });

  // Messaging
  var sendResult = session.messages.send('foo/bar', 'xyz', 'XXX-YYY');
  sendResult.then((result) => {
    console.log(result.path + result.recipient);
  }, (err) => { console.log(err); });
  var messageStream1 = session.messages.listen('x/y/z');
  var messageStream2 = session.messages.listen('bar/baz', (message) => {
    console.log(message.session + ':' + message.path + ':' + message.content);
  });
  messageStream1.on('message', (message) => {});

  // Security
  session.security.changePrincipal('admin', 'password').then(function() {
      console.log('Authenticated as admin');
  });
  session.security.getSecurityConfiguration().then(function(config) {
      console.log('Roles for anonymous sessions: ', config.anonymous);
      console.log('Roles for named sessions: ', config.named);
      console.log('Available roles: ', config.roles);
  }, function(error) {
      console.log('Unable to fetch security configuration', error);
  });
  var securityScriptBuilder = session.security.securityScriptBuilder();
  var setPermissionScript = securityScriptBuilder.setGlobalPermissions('SUPERUSER', ['REGISTER_HANDLER'])
                                                 .setTopicPermissions('SUPERUSER', '/foo', ['UPDATE_TOPIC'])
                                                 .build();
  session.security.updateSecurityStore(setPermissionScript).then(function() {
      console.log('Security configuration updated successfully');
  }, function(error) {
      console.log('Failed to update security configuration: ', error);
  });
  session.security.getSystemAuthenticationConfiguration().then(function(config) {
      console.log('System principals: ', config.principals);
      console.log('Anonymous sessions: ', config.anonymous);
  }, function(error) {
      console.log('Unable to fetch system authentication configuration', error);
  });
  var authenticationScriptBuilder = session.security.authenticationScriptBuilder();
  var addUserScript = authenticationScriptBuilder.addPrincipal('Superman', 'correcthorsebatterystapler')
                                                 .assignRoles('Superman', ['SUPERUSER'])
                                                 .build();
  session.security.updateAuthenticationStore(addUserScript).then(function() {
      console.log('Updated system authentication config');
  }, function(error) {
      console.log('Failed to update system authentication: ', error);
  });

  // Chain some promises a bit
  session.topics.add('foo/json1', value).then(function(result) {
    if (result.added) {
      return session.topics.remove(result.topic);
    }
  }, function(reason) {
    return reason;
  }).then(function() {
    return session.security.getSecurityConfiguration();
  }, function() {
    return session.topics.update('foo/bar', 'baz');
  }).then(function() {
    console.log("Chained");
  }, function() {
    console.log("Chained");
  });

}, function(error) { console.log('Failed to connect because of error: ' + error.message); });
