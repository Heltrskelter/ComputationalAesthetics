// Namespaced features
var Messages = require('features/messages');
var Security = require('features/security').Security;
var TopicControl = require('features/topic-control');
var ClientControl = require('features/client-control');

// Features to implement
var features = [
    require('features/topics')
];

/**
 *
 * Diffusion Session. Handles a connection to Diffusion and exposes API features. Sessions can subscribe, add, remove
 * and update topics, as well as perform remote operations on the server.
 * <P>
 * <br />
 * A session represents a single connection to a single Diffusion server. A session begins connected and will remain
 * so until until it is explicitly closed via {@link Session#close} or there is a connection error.
 * <P>
 * When a connected session loses its connection to the server, it will close if {@link Session.Options}
 * <code>reconnect</code> is not enabled. If reconnect is enabled then the session will enter a
 * <code>disconnected</code> state. Once disconnected, any API methods that involve the server will automatically fail.
 * It is possible for a session to lose messages while disconnected.
 * <P>
 * The session will attempt to reconnect to the server on a regular basis. This will continue until the server responds;
 * at which point the session will attempt to recover its previous connection.
 * <P>
 * If the reconnection is succesful the session will become connected again and emit a <code>reconnect</code> event.
 * Any prior subscriptions will continue to receive data.
 * <P>
 * If the server rejects the reconnection, the session will be closed.
 * <P>
 * Sessions emit events to notify listeners of changes in state. Certain events will provide arguments to any callback
 * functions that have been registered.
 *
 * @example
 * // Establish a session
 * diffusion.connect('diffusion.example.com').then(function(session) {
 *     // Attach state listeners
 *     session.on({
 *         disconnect : function() {
 *             console.log('Disconnected!');
 *         },
 *         reconnect : function() {
 *             console.log('Phew, reconnected!');
 *         },
 *         error : function(error) {
 *              console.log('Session error', error);
 *         },
 *         close : function(reason) {
 *             console.log('Session closed', reason);
 *         }
 *     });
 *
 *     // Do something with session...
 * });
 *
 * @class Session
 *
 * @fires Session#disconnect
 * @fires Session#reconnect
 * @fires Session#error
 * @fires Session#close
 *
 * @property {Session.security} security - Exposes system authentication capabilities via a {@link Session.security}.
 * @property {Session.topics} topics - Exposes topic control capabilities via {@link Session.topics}.
 * @property {Session.messages} messages - Exposes messaging capabilities via {@link Session.messages}.
 * @property {Session.clients} clients - Exposes client control capabilities via {@link Session.clients}.
 * @property {Session.Options} options - The options used when connecting.
 * @property {String} sessionID - The unique id assigned to this session by the server.
 *
 * @augments Stream
 */

// private constructor
function Session(internalSession, emitter, options) {
    /*
     * The unique id assigned to this session by the server.
     */
    // Will be set by SessionImpl#connect
    this.sessionID = undefined;

    /*
     * The options used when connecting.
     */
    this.options = options;

    var self = this;

    // Assign ourselves as a stream
    emitter.assign(self);

    // Self-assign feature implementations onto session
    features.forEach(function(feature) {
        var instance = new feature(internalSession);
        for (var k in instance) {
            self[k] = instance[k];
        }
    });

    /**
     * Close this session's connection to the server.
     * <P>
     * Calling this repeatedly will have no effect.
     *
     * @function Session#close
     * @return {Session} This session
     */
    this.close = function() {
        internalSession.close();
        return self;
    };

    /**
     * Indicates if this session is currently connected.
     * <P>
     * This is orthogonal to {@link Session#isClosed}, as a session may
     * be disconnected and attempting to reconnect.
     *
     * @function Session#isConnected
     * @return {boolean} Whether the session is currently connected or not.
     */
    this.isConnected = function() {
        return internalSession.isConnected();
    };

    /**
     * Indicates if this session is currently closed, or in the process of
     * closing.
     * <P>
     * This will not return <code>true</code> if the session is disconnected
     * but attempting to reconnect.
     *
     * @function Session#isClosed
     * @return {boolean} Whether the session is currently closed.
     */
    this.isClosed = function() {
        var state = internalSession.getState();
        return state === "closing" || state === "closed";
    };

    this.security = new Security(internalSession, this);

    this.topics = new TopicControl(internalSession, this);

    this.messages = new Messages(internalSession, this);

    this.clients = new ClientControl(internalSession, this);

    this.toString = function() {
        return "Session<" + self.sessionID + " " + internalSession.getState() + ">";
    };

    /**
     *  Emitted when a connected session has lost connection to the server, and {@link Session.Options}
     * <code>reconnect</code> is enabled.
     *
     * @event Session#disconnect
     */

    /**
     * Emitted when a disconnected session has successfully reconnected.
     * @event Session#reconnect
     */

    /**
     * Emitted when a session error has occurred. A session error occurs when
     * the client cannot parse communication from the server. This occurs if a component
     * between the two - for example, a proxy or load balancer - alters the communication.
     *
     * @event Session#error
     * @property {Error} error - the error that occured.
     */

    /**
     * Emitted when a session is closed. This can occur because it was closed by the user, closed by the server, failed
     * to connect, or the session encountered an error. The provided close reason will contain the specific cause of the
     * session close.
     *
     * @event Session#close
     * @property {object} reason - the cause of the session close.
     */
}

module.exports = Session;
